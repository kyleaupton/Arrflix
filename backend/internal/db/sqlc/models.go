// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package dbgen

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

type AuthProvider string

const (
	AuthProviderLocal AuthProvider = "local"
	AuthProviderPlex  AuthProvider = "plex"
)

func (e *AuthProvider) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuthProvider(s)
	case string:
		*e = AuthProvider(s)
	default:
		return fmt.Errorf("unsupported scan type for AuthProvider: %T", src)
	}
	return nil
}

type NullAuthProvider struct {
	AuthProvider AuthProvider `json:"auth_provider"`
	Valid        bool         `json:"valid"` // Valid is true if AuthProvider is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuthProvider) Scan(value interface{}) error {
	if value == nil {
		ns.AuthProvider, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuthProvider.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuthProvider) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuthProvider), nil
}

type GrantEffect string

const (
	GrantEffectAllow GrantEffect = "allow"
	GrantEffectDeny  GrantEffect = "deny"
)

func (e *GrantEffect) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GrantEffect(s)
	case string:
		*e = GrantEffect(s)
	default:
		return fmt.Errorf("unsupported scan type for GrantEffect: %T", src)
	}
	return nil
}

type NullGrantEffect struct {
	GrantEffect GrantEffect `json:"grant_effect"`
	Valid       bool        `json:"valid"` // Valid is true if GrantEffect is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGrantEffect) Scan(value interface{}) error {
	if value == nil {
		ns.GrantEffect, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GrantEffect.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGrantEffect) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GrantEffect), nil
}

type GrantSubject string

const (
	GrantSubjectRole GrantSubject = "role"
	GrantSubjectUser GrantSubject = "user"
)

func (e *GrantSubject) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GrantSubject(s)
	case string:
		*e = GrantSubject(s)
	default:
		return fmt.Errorf("unsupported scan type for GrantSubject: %T", src)
	}
	return nil
}

type NullGrantSubject struct {
	GrantSubject GrantSubject `json:"grant_subject"`
	Valid        bool         `json:"valid"` // Valid is true if GrantSubject is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGrantSubject) Scan(value interface{}) error {
	if value == nil {
		ns.GrantSubject, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GrantSubject.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGrantSubject) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GrantSubject), nil
}

type Action struct {
	ID        pgtype.UUID `json:"id"`
	PolicyID  pgtype.UUID `json:"policy_id"`
	Type      string      `json:"type"`
	Value     string      `json:"value"`
	Order     int32       `json:"order"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

type ApiCache struct {
	ID          pgtype.UUID `json:"id"`
	Key         string      `json:"key"`
	Category    *string     `json:"category"`
	Response    []byte      `json:"response"`
	Status      int32       `json:"status"`
	ContentType *string     `json:"content_type"`
	Headers     []byte      `json:"headers"`
	StoredAt    time.Time   `json:"stored_at"`
	ExpiresAt   time.Time   `json:"expires_at"`
}

type AppSetting struct {
	Key       string    `json:"key"`
	Type      string    `json:"type"`
	ValueJson []byte    `json:"value_json"`
	Version   int32     `json:"version"`
	UpdatedAt time.Time `json:"updated_at"`
}

type AppUser struct {
	ID           pgtype.UUID `json:"id"`
	Email        *string     `json:"email"`
	DisplayName  *string     `json:"display_name"`
	AvatarUrl    *string     `json:"avatar_url"`
	PasswordHash *string     `json:"password_hash"`
	IsActive     bool        `json:"is_active"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
}

type AuthAudit struct {
	ID        pgtype.UUID `json:"id"`
	UserID    pgtype.UUID `json:"user_id"`
	Event     string      `json:"event"`
	Detail    []byte      `json:"detail"`
	CreatedAt time.Time   `json:"created_at"`
}

type DownloadJob struct {
	ID                   pgtype.UUID `json:"id"`
	Status               string      `json:"status"`
	Protocol             string      `json:"protocol"`
	MediaType            string      `json:"media_type"`
	MediaItemID          pgtype.UUID `json:"media_item_id"`
	SeasonID             pgtype.UUID `json:"season_id"`
	EpisodeID            pgtype.UUID `json:"episode_id"`
	IndexerID            int64       `json:"indexer_id"`
	Guid                 string      `json:"guid"`
	CandidateTitle       string      `json:"candidate_title"`
	CandidateLink        string      `json:"candidate_link"`
	DownloaderID         pgtype.UUID `json:"downloader_id"`
	LibraryID            pgtype.UUID `json:"library_id"`
	NameTemplateID       pgtype.UUID `json:"name_template_id"`
	DownloaderExternalID *string     `json:"downloader_external_id"`
	DownloadSavePath     *string     `json:"download_save_path"`
	DownloadContentPath  *string     `json:"download_content_path"`
	ImportSourcePath     *string     `json:"import_source_path"`
	ImportDestPath       *string     `json:"import_dest_path"`
	ImportMethod         *string     `json:"import_method"`
	PrimaryMediaFileID   pgtype.UUID `json:"primary_media_file_id"`
	DownloaderStatus     *string     `json:"downloader_status"`
	Progress             *float64    `json:"progress"`
	AttemptCount         int32       `json:"attempt_count"`
	NextRunAt            time.Time   `json:"next_run_at"`
	LastError            *string     `json:"last_error"`
	CreatedAt            time.Time   `json:"created_at"`
	UpdatedAt            time.Time   `json:"updated_at"`
}

type DownloadJobMediaFile struct {
	DownloadJobID pgtype.UUID `json:"download_job_id"`
	MediaFileID   pgtype.UUID `json:"media_file_id"`
	CreatedAt     time.Time   `json:"created_at"`
}

type Downloader struct {
	ID         pgtype.UUID `json:"id"`
	Name       string      `json:"name"`
	Type       string      `json:"type"`
	Protocol   string      `json:"protocol"`
	Url        string      `json:"url"`
	Username   *string     `json:"username"`
	Password   *string     `json:"password"`
	ConfigJson []byte      `json:"config_json"`
	Enabled    bool        `json:"enabled"`
	Default    bool        `json:"default"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
}

type Library struct {
	ID        pgtype.UUID `json:"id"`
	Name      string      `json:"name"`
	Type      string      `json:"type"`
	RootPath  string      `json:"root_path"`
	Enabled   bool        `json:"enabled"`
	Default   bool        `json:"default"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

type MediaEpisode struct {
	ID            pgtype.UUID `json:"id"`
	SeasonID      pgtype.UUID `json:"season_id"`
	EpisodeNumber int32       `json:"episode_number"`
	Title         *string     `json:"title"`
	AirDate       pgtype.Date `json:"air_date"`
	TmdbID        *int64      `json:"tmdb_id"`
	TvdbID        *int64      `json:"tvdb_id"`
	CreatedAt     time.Time   `json:"created_at"`
}

type MediaFile struct {
	ID          pgtype.UUID `json:"id"`
	LibraryID   pgtype.UUID `json:"library_id"`
	MediaItemID pgtype.UUID `json:"media_item_id"`
	SeasonID    pgtype.UUID `json:"season_id"`
	EpisodeID   pgtype.UUID `json:"episode_id"`
	Path        string      `json:"path"`
	Status      string      `json:"status"`
	AddedAt     time.Time   `json:"added_at"`
}

type MediaItem struct {
	ID        pgtype.UUID `json:"id"`
	Type      string      `json:"type"`
	Title     string      `json:"title"`
	Year      *int32      `json:"year"`
	TmdbID    *int64      `json:"tmdb_id"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

type MediaSeason struct {
	ID           pgtype.UUID `json:"id"`
	MediaItemID  pgtype.UUID `json:"media_item_id"`
	SeasonNumber int32       `json:"season_number"`
	AirDate      pgtype.Date `json:"air_date"`
	CreatedAt    time.Time   `json:"created_at"`
}

type NameTemplate struct {
	ID        pgtype.UUID `json:"id"`
	Name      string      `json:"name"`
	Type      string      `json:"type"`
	Template  string      `json:"template"`
	Default   bool        `json:"default"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

type Permission struct {
	ID          pgtype.UUID `json:"id"`
	Key         string      `json:"key"`
	Description *string     `json:"description"`
}

type PermissionGrant struct {
	ID            pgtype.UUID  `json:"id"`
	SubjectType   GrantSubject `json:"subject_type"`
	SubjectID     pgtype.UUID  `json:"subject_id"`
	PermissionKey string       `json:"permission_key"`
	ResourceType  *string      `json:"resource_type"`
	ResourceID    pgtype.UUID  `json:"resource_id"`
	Effect        GrantEffect  `json:"effect"`
	CreatedAt     time.Time    `json:"created_at"`
}

type Policy struct {
	ID          pgtype.UUID `json:"id"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	Enabled     bool        `json:"enabled"`
	Priority    int32       `json:"priority"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
}

type Role struct {
	ID          pgtype.UUID `json:"id"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	BuiltIn     bool        `json:"built_in"`
	CreatedAt   time.Time   `json:"created_at"`
}

type Rule struct {
	ID           pgtype.UUID `json:"id"`
	PolicyID     pgtype.UUID `json:"policy_id"`
	LeftOperand  string      `json:"left_operand"`
	Operator     string      `json:"operator"`
	RightOperand string      `json:"right_operand"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
}

type ServiceInstance struct {
	ID        pgtype.UUID `json:"id"`
	Name      string      `json:"name"`
	Type      string      `json:"type"`
	Enabled   bool        `json:"enabled"`
	Config    []byte      `json:"config"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

type UserIdentity struct {
	ID             pgtype.UUID        `json:"id"`
	UserID         pgtype.UUID        `json:"user_id"`
	Provider       AuthProvider       `json:"provider"`
	Subject        string             `json:"subject"`
	Username       *string            `json:"username"`
	AccessToken    *string            `json:"access_token"`
	RefreshToken   *string            `json:"refresh_token"`
	TokenExpiresAt pgtype.Timestamptz `json:"token_expires_at"`
	Raw            []byte             `json:"raw"`
	CreatedAt      time.Time          `json:"created_at"`
}

type UserRole struct {
	UserID    pgtype.UUID `json:"user_id"`
	RoleID    pgtype.UUID `json:"role_id"`
	GrantedAt time.Time   `json:"granted_at"`
}
