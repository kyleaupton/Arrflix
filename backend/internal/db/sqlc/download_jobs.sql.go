// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: download_jobs.sql

package dbgen

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const bumpDownloadJobRetry = `-- name: BumpDownloadJobRetry :one
update download_job
set attempt_count = attempt_count + 1,
    last_error = $1,
    next_run_at = $2,
    updated_at = now()
where id = $3
returning id, status, protocol, media_type, media_item_id, season_id, episode_id, indexer_id, guid, candidate_title, candidate_link, downloader_id, library_id, name_template_id, downloader_external_id, download_save_path, download_content_path, import_source_path, import_dest_path, import_method, downloader_status, progress, attempt_count, next_run_at, last_error, created_at, updated_at
`

type BumpDownloadJobRetryParams struct {
	LastError *string     `json:"last_error"`
	NextRunAt time.Time   `json:"next_run_at"`
	ID        pgtype.UUID `json:"id"`
}

func (q *Queries) BumpDownloadJobRetry(ctx context.Context, arg BumpDownloadJobRetryParams) (DownloadJob, error) {
	row := q.db.QueryRow(ctx, bumpDownloadJobRetry, arg.LastError, arg.NextRunAt, arg.ID)
	var i DownloadJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Protocol,
		&i.MediaType,
		&i.MediaItemID,
		&i.SeasonID,
		&i.EpisodeID,
		&i.IndexerID,
		&i.Guid,
		&i.CandidateTitle,
		&i.CandidateLink,
		&i.DownloaderID,
		&i.LibraryID,
		&i.NameTemplateID,
		&i.DownloaderExternalID,
		&i.DownloadSavePath,
		&i.DownloadContentPath,
		&i.ImportSourcePath,
		&i.ImportDestPath,
		&i.ImportMethod,
		&i.DownloaderStatus,
		&i.Progress,
		&i.AttemptCount,
		&i.NextRunAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const cancelDownloadJob = `-- name: CancelDownloadJob :one
update download_job
set status = 'cancelled',
    updated_at = now()
where id = $1
returning id, status, protocol, media_type, media_item_id, season_id, episode_id, indexer_id, guid, candidate_title, candidate_link, downloader_id, library_id, name_template_id, downloader_external_id, download_save_path, download_content_path, import_source_path, import_dest_path, import_method, downloader_status, progress, attempt_count, next_run_at, last_error, created_at, updated_at
`

func (q *Queries) CancelDownloadJob(ctx context.Context, id pgtype.UUID) (DownloadJob, error) {
	row := q.db.QueryRow(ctx, cancelDownloadJob, id)
	var i DownloadJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Protocol,
		&i.MediaType,
		&i.MediaItemID,
		&i.SeasonID,
		&i.EpisodeID,
		&i.IndexerID,
		&i.Guid,
		&i.CandidateTitle,
		&i.CandidateLink,
		&i.DownloaderID,
		&i.LibraryID,
		&i.NameTemplateID,
		&i.DownloaderExternalID,
		&i.DownloadSavePath,
		&i.DownloadContentPath,
		&i.ImportSourcePath,
		&i.ImportDestPath,
		&i.ImportMethod,
		&i.DownloaderStatus,
		&i.Progress,
		&i.AttemptCount,
		&i.NextRunAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const claimRunnableDownloadJobs = `-- name: ClaimRunnableDownloadJobs :many
with cte as (
  select id
  from download_job
  where status in ('created','enqueued','downloading','completed','importing')
    and next_run_at <= now()
  order by next_run_at asc
  for update skip locked
  limit $1
)
update download_job j
set updated_at = now()
from cte
where j.id = cte.id
returning j.id, j.status, j.protocol, j.media_type, j.media_item_id, j.season_id, j.episode_id, j.indexer_id, j.guid, j.candidate_title, j.candidate_link, j.downloader_id, j.library_id, j.name_template_id, j.downloader_external_id, j.download_save_path, j.download_content_path, j.import_source_path, j.import_dest_path, j.import_method, j.downloader_status, j.progress, j.attempt_count, j.next_run_at, j.last_error, j.created_at, j.updated_at
`

func (q *Queries) ClaimRunnableDownloadJobs(ctx context.Context, limit int32) ([]DownloadJob, error) {
	rows, err := q.db.Query(ctx, claimRunnableDownloadJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DownloadJob
	for rows.Next() {
		var i DownloadJob
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Protocol,
			&i.MediaType,
			&i.MediaItemID,
			&i.SeasonID,
			&i.EpisodeID,
			&i.IndexerID,
			&i.Guid,
			&i.CandidateTitle,
			&i.CandidateLink,
			&i.DownloaderID,
			&i.LibraryID,
			&i.NameTemplateID,
			&i.DownloaderExternalID,
			&i.DownloadSavePath,
			&i.DownloadContentPath,
			&i.ImportSourcePath,
			&i.ImportDestPath,
			&i.ImportMethod,
			&i.DownloaderStatus,
			&i.Progress,
			&i.AttemptCount,
			&i.NextRunAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createDownloadJob = `-- name: CreateDownloadJob :one

insert into download_job (
  status,
  protocol,
  media_type,
  media_item_id,
  season_id,
  episode_id,
  indexer_id,
  guid,
  candidate_title,
  candidate_link,
  downloader_id,
  library_id,
  name_template_id
)
values (
  'created',
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12
)
on conflict (indexer_id, guid) do update
set updated_at = now()
returning id, status, protocol, media_type, media_item_id, season_id, episode_id, indexer_id, guid, candidate_title, candidate_link, downloader_id, library_id, name_template_id, downloader_external_id, download_save_path, download_content_path, import_source_path, import_dest_path, import_method, downloader_status, progress, attempt_count, next_run_at, last_error, created_at, updated_at
`

type CreateDownloadJobParams struct {
	Protocol       string      `json:"protocol"`
	MediaType      string      `json:"media_type"`
	MediaItemID    pgtype.UUID `json:"media_item_id"`
	SeasonID       pgtype.UUID `json:"season_id"`
	EpisodeID      pgtype.UUID `json:"episode_id"`
	IndexerID      int64       `json:"indexer_id"`
	Guid           string      `json:"guid"`
	CandidateTitle string      `json:"candidate_title"`
	CandidateLink  string      `json:"candidate_link"`
	DownloaderID   pgtype.UUID `json:"downloader_id"`
	LibraryID      pgtype.UUID `json:"library_id"`
	NameTemplateID pgtype.UUID `json:"name_template_id"`
}

// Download jobs
func (q *Queries) CreateDownloadJob(ctx context.Context, arg CreateDownloadJobParams) (DownloadJob, error) {
	row := q.db.QueryRow(ctx, createDownloadJob,
		arg.Protocol,
		arg.MediaType,
		arg.MediaItemID,
		arg.SeasonID,
		arg.EpisodeID,
		arg.IndexerID,
		arg.Guid,
		arg.CandidateTitle,
		arg.CandidateLink,
		arg.DownloaderID,
		arg.LibraryID,
		arg.NameTemplateID,
	)
	var i DownloadJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Protocol,
		&i.MediaType,
		&i.MediaItemID,
		&i.SeasonID,
		&i.EpisodeID,
		&i.IndexerID,
		&i.Guid,
		&i.CandidateTitle,
		&i.CandidateLink,
		&i.DownloaderID,
		&i.LibraryID,
		&i.NameTemplateID,
		&i.DownloaderExternalID,
		&i.DownloadSavePath,
		&i.DownloadContentPath,
		&i.ImportSourcePath,
		&i.ImportDestPath,
		&i.ImportMethod,
		&i.DownloaderStatus,
		&i.Progress,
		&i.AttemptCount,
		&i.NextRunAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDownloadJob = `-- name: GetDownloadJob :one
select id, status, protocol, media_type, media_item_id, season_id, episode_id, indexer_id, guid, candidate_title, candidate_link, downloader_id, library_id, name_template_id, downloader_external_id, download_save_path, download_content_path, import_source_path, import_dest_path, import_method, downloader_status, progress, attempt_count, next_run_at, last_error, created_at, updated_at from download_job
where id = $1
`

func (q *Queries) GetDownloadJob(ctx context.Context, id pgtype.UUID) (DownloadJob, error) {
	row := q.db.QueryRow(ctx, getDownloadJob, id)
	var i DownloadJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Protocol,
		&i.MediaType,
		&i.MediaItemID,
		&i.SeasonID,
		&i.EpisodeID,
		&i.IndexerID,
		&i.Guid,
		&i.CandidateTitle,
		&i.CandidateLink,
		&i.DownloaderID,
		&i.LibraryID,
		&i.NameTemplateID,
		&i.DownloaderExternalID,
		&i.DownloadSavePath,
		&i.DownloadContentPath,
		&i.ImportSourcePath,
		&i.ImportDestPath,
		&i.ImportMethod,
		&i.DownloaderStatus,
		&i.Progress,
		&i.AttemptCount,
		&i.NextRunAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDownloadJobByCandidate = `-- name: GetDownloadJobByCandidate :one
select id, status, protocol, media_type, media_item_id, season_id, episode_id, indexer_id, guid, candidate_title, candidate_link, downloader_id, library_id, name_template_id, downloader_external_id, download_save_path, download_content_path, import_source_path, import_dest_path, import_method, downloader_status, progress, attempt_count, next_run_at, last_error, created_at, updated_at from download_job
where indexer_id = $1 and guid = $2
`

type GetDownloadJobByCandidateParams struct {
	IndexerID int64  `json:"indexer_id"`
	Guid      string `json:"guid"`
}

func (q *Queries) GetDownloadJobByCandidate(ctx context.Context, arg GetDownloadJobByCandidateParams) (DownloadJob, error) {
	row := q.db.QueryRow(ctx, getDownloadJobByCandidate, arg.IndexerID, arg.Guid)
	var i DownloadJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Protocol,
		&i.MediaType,
		&i.MediaItemID,
		&i.SeasonID,
		&i.EpisodeID,
		&i.IndexerID,
		&i.Guid,
		&i.CandidateTitle,
		&i.CandidateLink,
		&i.DownloaderID,
		&i.LibraryID,
		&i.NameTemplateID,
		&i.DownloaderExternalID,
		&i.DownloadSavePath,
		&i.DownloadContentPath,
		&i.ImportSourcePath,
		&i.ImportDestPath,
		&i.ImportMethod,
		&i.DownloaderStatus,
		&i.Progress,
		&i.AttemptCount,
		&i.NextRunAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDownloadJobs = `-- name: ListDownloadJobs :many
select id, status, protocol, media_type, media_item_id, season_id, episode_id, indexer_id, guid, candidate_title, candidate_link, downloader_id, library_id, name_template_id, downloader_external_id, download_save_path, download_content_path, import_source_path, import_dest_path, import_method, downloader_status, progress, attempt_count, next_run_at, last_error, created_at, updated_at from download_job
order by created_at desc
`

func (q *Queries) ListDownloadJobs(ctx context.Context) ([]DownloadJob, error) {
	rows, err := q.db.Query(ctx, listDownloadJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DownloadJob
	for rows.Next() {
		var i DownloadJob
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Protocol,
			&i.MediaType,
			&i.MediaItemID,
			&i.SeasonID,
			&i.EpisodeID,
			&i.IndexerID,
			&i.Guid,
			&i.CandidateTitle,
			&i.CandidateLink,
			&i.DownloaderID,
			&i.LibraryID,
			&i.NameTemplateID,
			&i.DownloaderExternalID,
			&i.DownloadSavePath,
			&i.DownloadContentPath,
			&i.ImportSourcePath,
			&i.ImportDestPath,
			&i.ImportMethod,
			&i.DownloaderStatus,
			&i.Progress,
			&i.AttemptCount,
			&i.NextRunAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDownloadJobsByMediaItem = `-- name: ListDownloadJobsByMediaItem :many
select id, status, protocol, media_type, media_item_id, season_id, episode_id, indexer_id, guid, candidate_title, candidate_link, downloader_id, library_id, name_template_id, downloader_external_id, download_save_path, download_content_path, import_source_path, import_dest_path, import_method, downloader_status, progress, attempt_count, next_run_at, last_error, created_at, updated_at from download_job
where media_item_id = $1
order by created_at desc
`

func (q *Queries) ListDownloadJobsByMediaItem(ctx context.Context, mediaItemID pgtype.UUID) ([]DownloadJob, error) {
	rows, err := q.db.Query(ctx, listDownloadJobsByMediaItem, mediaItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DownloadJob
	for rows.Next() {
		var i DownloadJob
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Protocol,
			&i.MediaType,
			&i.MediaItemID,
			&i.SeasonID,
			&i.EpisodeID,
			&i.IndexerID,
			&i.Guid,
			&i.CandidateTitle,
			&i.CandidateLink,
			&i.DownloaderID,
			&i.LibraryID,
			&i.NameTemplateID,
			&i.DownloaderExternalID,
			&i.DownloadSavePath,
			&i.DownloadContentPath,
			&i.ImportSourcePath,
			&i.ImportDestPath,
			&i.ImportMethod,
			&i.DownloaderStatus,
			&i.Progress,
			&i.AttemptCount,
			&i.NextRunAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDownloadJobsByTmdbMovieID = `-- name: ListDownloadJobsByTmdbMovieID :many
select j.id, j.status, j.protocol, j.media_type, j.media_item_id, j.season_id, j.episode_id, j.indexer_id, j.guid, j.candidate_title, j.candidate_link, j.downloader_id, j.library_id, j.name_template_id, j.downloader_external_id, j.download_save_path, j.download_content_path, j.import_source_path, j.import_dest_path, j.import_method, j.downloader_status, j.progress, j.attempt_count, j.next_run_at, j.last_error, j.created_at, j.updated_at
from download_job j
join media_item mi on mi.id = j.media_item_id
where mi.type = 'movie' and mi.tmdb_id = $1
order by j.created_at desc
`

func (q *Queries) ListDownloadJobsByTmdbMovieID(ctx context.Context, tmdbID *int64) ([]DownloadJob, error) {
	rows, err := q.db.Query(ctx, listDownloadJobsByTmdbMovieID, tmdbID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DownloadJob
	for rows.Next() {
		var i DownloadJob
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Protocol,
			&i.MediaType,
			&i.MediaItemID,
			&i.SeasonID,
			&i.EpisodeID,
			&i.IndexerID,
			&i.Guid,
			&i.CandidateTitle,
			&i.CandidateLink,
			&i.DownloaderID,
			&i.LibraryID,
			&i.NameTemplateID,
			&i.DownloaderExternalID,
			&i.DownloadSavePath,
			&i.DownloadContentPath,
			&i.ImportSourcePath,
			&i.ImportDestPath,
			&i.ImportMethod,
			&i.DownloaderStatus,
			&i.Progress,
			&i.AttemptCount,
			&i.NextRunAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDownloadJobFailed = `-- name: MarkDownloadJobFailed :one
update download_job
set status = 'failed',
    last_error = $1,
    updated_at = now()
where id = $2
returning id, status, protocol, media_type, media_item_id, season_id, episode_id, indexer_id, guid, candidate_title, candidate_link, downloader_id, library_id, name_template_id, downloader_external_id, download_save_path, download_content_path, import_source_path, import_dest_path, import_method, downloader_status, progress, attempt_count, next_run_at, last_error, created_at, updated_at
`

type MarkDownloadJobFailedParams struct {
	LastError *string     `json:"last_error"`
	ID        pgtype.UUID `json:"id"`
}

func (q *Queries) MarkDownloadJobFailed(ctx context.Context, arg MarkDownloadJobFailedParams) (DownloadJob, error) {
	row := q.db.QueryRow(ctx, markDownloadJobFailed, arg.LastError, arg.ID)
	var i DownloadJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Protocol,
		&i.MediaType,
		&i.MediaItemID,
		&i.SeasonID,
		&i.EpisodeID,
		&i.IndexerID,
		&i.Guid,
		&i.CandidateTitle,
		&i.CandidateLink,
		&i.DownloaderID,
		&i.LibraryID,
		&i.NameTemplateID,
		&i.DownloaderExternalID,
		&i.DownloadSavePath,
		&i.DownloadContentPath,
		&i.ImportSourcePath,
		&i.ImportDestPath,
		&i.ImportMethod,
		&i.DownloaderStatus,
		&i.Progress,
		&i.AttemptCount,
		&i.NextRunAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setDownloadJobDownloadSnapshot = `-- name: SetDownloadJobDownloadSnapshot :one
update download_job
set status = $1,
    downloader_status = $2,
    progress = $3,
    download_save_path = $4,
    download_content_path = $5,
    updated_at = now()
where id = $6
returning id, status, protocol, media_type, media_item_id, season_id, episode_id, indexer_id, guid, candidate_title, candidate_link, downloader_id, library_id, name_template_id, downloader_external_id, download_save_path, download_content_path, import_source_path, import_dest_path, import_method, downloader_status, progress, attempt_count, next_run_at, last_error, created_at, updated_at
`

type SetDownloadJobDownloadSnapshotParams struct {
	Status              string      `json:"status"`
	DownloaderStatus    *string     `json:"downloader_status"`
	Progress            *float64    `json:"progress"`
	DownloadSavePath    *string     `json:"download_save_path"`
	DownloadContentPath *string     `json:"download_content_path"`
	ID                  pgtype.UUID `json:"id"`
}

func (q *Queries) SetDownloadJobDownloadSnapshot(ctx context.Context, arg SetDownloadJobDownloadSnapshotParams) (DownloadJob, error) {
	row := q.db.QueryRow(ctx, setDownloadJobDownloadSnapshot,
		arg.Status,
		arg.DownloaderStatus,
		arg.Progress,
		arg.DownloadSavePath,
		arg.DownloadContentPath,
		arg.ID,
	)
	var i DownloadJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Protocol,
		&i.MediaType,
		&i.MediaItemID,
		&i.SeasonID,
		&i.EpisodeID,
		&i.IndexerID,
		&i.Guid,
		&i.CandidateTitle,
		&i.CandidateLink,
		&i.DownloaderID,
		&i.LibraryID,
		&i.NameTemplateID,
		&i.DownloaderExternalID,
		&i.DownloadSavePath,
		&i.DownloadContentPath,
		&i.ImportSourcePath,
		&i.ImportDestPath,
		&i.ImportMethod,
		&i.DownloaderStatus,
		&i.Progress,
		&i.AttemptCount,
		&i.NextRunAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setDownloadJobEnqueued = `-- name: SetDownloadJobEnqueued :one
update download_job
set status = 'enqueued',
    downloader_external_id = $1,
    updated_at = now()
where id = $2
returning id, status, protocol, media_type, media_item_id, season_id, episode_id, indexer_id, guid, candidate_title, candidate_link, downloader_id, library_id, name_template_id, downloader_external_id, download_save_path, download_content_path, import_source_path, import_dest_path, import_method, downloader_status, progress, attempt_count, next_run_at, last_error, created_at, updated_at
`

type SetDownloadJobEnqueuedParams struct {
	DownloaderExternalID *string     `json:"downloader_external_id"`
	ID                   pgtype.UUID `json:"id"`
}

func (q *Queries) SetDownloadJobEnqueued(ctx context.Context, arg SetDownloadJobEnqueuedParams) (DownloadJob, error) {
	row := q.db.QueryRow(ctx, setDownloadJobEnqueued, arg.DownloaderExternalID, arg.ID)
	var i DownloadJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Protocol,
		&i.MediaType,
		&i.MediaItemID,
		&i.SeasonID,
		&i.EpisodeID,
		&i.IndexerID,
		&i.Guid,
		&i.CandidateTitle,
		&i.CandidateLink,
		&i.DownloaderID,
		&i.LibraryID,
		&i.NameTemplateID,
		&i.DownloaderExternalID,
		&i.DownloadSavePath,
		&i.DownloadContentPath,
		&i.ImportSourcePath,
		&i.ImportDestPath,
		&i.ImportMethod,
		&i.DownloaderStatus,
		&i.Progress,
		&i.AttemptCount,
		&i.NextRunAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setDownloadJobImported = `-- name: SetDownloadJobImported :one
update download_job
set status = 'imported',
    import_source_path = $1,
    import_dest_path = $2,
    import_method = $3,
    updated_at = now()
where id = $4
returning id, status, protocol, media_type, media_item_id, season_id, episode_id, indexer_id, guid, candidate_title, candidate_link, downloader_id, library_id, name_template_id, downloader_external_id, download_save_path, download_content_path, import_source_path, import_dest_path, import_method, downloader_status, progress, attempt_count, next_run_at, last_error, created_at, updated_at
`

type SetDownloadJobImportedParams struct {
	ImportSourcePath *string     `json:"import_source_path"`
	ImportDestPath   *string     `json:"import_dest_path"`
	ImportMethod     *string     `json:"import_method"`
	ID               pgtype.UUID `json:"id"`
}

func (q *Queries) SetDownloadJobImported(ctx context.Context, arg SetDownloadJobImportedParams) (DownloadJob, error) {
	row := q.db.QueryRow(ctx, setDownloadJobImported,
		arg.ImportSourcePath,
		arg.ImportDestPath,
		arg.ImportMethod,
		arg.ID,
	)
	var i DownloadJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Protocol,
		&i.MediaType,
		&i.MediaItemID,
		&i.SeasonID,
		&i.EpisodeID,
		&i.IndexerID,
		&i.Guid,
		&i.CandidateTitle,
		&i.CandidateLink,
		&i.DownloaderID,
		&i.LibraryID,
		&i.NameTemplateID,
		&i.DownloaderExternalID,
		&i.DownloadSavePath,
		&i.DownloadContentPath,
		&i.ImportSourcePath,
		&i.ImportDestPath,
		&i.ImportMethod,
		&i.DownloaderStatus,
		&i.Progress,
		&i.AttemptCount,
		&i.NextRunAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setDownloadJobImporting = `-- name: SetDownloadJobImporting :one
update download_job
set status = 'importing',
    import_source_path = $1,
    updated_at = now()
where id = $2
returning id, status, protocol, media_type, media_item_id, season_id, episode_id, indexer_id, guid, candidate_title, candidate_link, downloader_id, library_id, name_template_id, downloader_external_id, download_save_path, download_content_path, import_source_path, import_dest_path, import_method, downloader_status, progress, attempt_count, next_run_at, last_error, created_at, updated_at
`

type SetDownloadJobImportingParams struct {
	ImportSourcePath *string     `json:"import_source_path"`
	ID               pgtype.UUID `json:"id"`
}

func (q *Queries) SetDownloadJobImporting(ctx context.Context, arg SetDownloadJobImportingParams) (DownloadJob, error) {
	row := q.db.QueryRow(ctx, setDownloadJobImporting, arg.ImportSourcePath, arg.ID)
	var i DownloadJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Protocol,
		&i.MediaType,
		&i.MediaItemID,
		&i.SeasonID,
		&i.EpisodeID,
		&i.IndexerID,
		&i.Guid,
		&i.CandidateTitle,
		&i.CandidateLink,
		&i.DownloaderID,
		&i.LibraryID,
		&i.NameTemplateID,
		&i.DownloaderExternalID,
		&i.DownloadSavePath,
		&i.DownloadContentPath,
		&i.ImportSourcePath,
		&i.ImportDestPath,
		&i.ImportMethod,
		&i.DownloaderStatus,
		&i.Progress,
		&i.AttemptCount,
		&i.NextRunAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
