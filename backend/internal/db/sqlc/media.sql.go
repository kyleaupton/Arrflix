// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: media.sql

package dbgen

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMediaItems = `-- name: CountMediaItems :one
SELECT COUNT(*) FROM media_item
WHERE
    ($1::text IS NULL OR type = $1) AND
    ($2::text IS NULL OR title ILIKE '%' || $2 || '%')
`

type CountMediaItemsParams struct {
	TypeFilter *string `json:"type_filter"`
	Search     *string `json:"search"`
}

func (q *Queries) CountMediaItems(ctx context.Context, arg CountMediaItemsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMediaItems, arg.TypeFilter, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnmatchedFiles = `-- name: CountUnmatchedFiles :one
select count(*) from unmatched_file
where resolved_at is null
  and ($1::uuid is null or library_id = $1)
`

func (q *Queries) CountUnmatchedFiles(ctx context.Context, libraryID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUnmatchedFiles, libraryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMediaFile = `-- name: CreateMediaFile :one
insert into media_file (library_id, media_item_id, episode_id, path)
values ($1, $2, $3, $4)
returning id, library_id, media_item_id, episode_id, path, created_at
`

type CreateMediaFileParams struct {
	LibraryID   pgtype.UUID `json:"library_id"`
	MediaItemID pgtype.UUID `json:"media_item_id"`
	EpisodeID   pgtype.UUID `json:"episode_id"`
	Path        string      `json:"path"`
}

func (q *Queries) CreateMediaFile(ctx context.Context, arg CreateMediaFileParams) (MediaFile, error) {
	row := q.db.QueryRow(ctx, createMediaFile,
		arg.LibraryID,
		arg.MediaItemID,
		arg.EpisodeID,
		arg.Path,
	)
	var i MediaFile
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.MediaItemID,
		&i.EpisodeID,
		&i.Path,
		&i.CreatedAt,
	)
	return i, err
}

const createMediaFileImport = `-- name: CreateMediaFileImport :one

insert into media_file_import (media_file_id, import_task_id, method, source_path, dest_path, success, error_message)
values ($1, $2, $3, $4, $5, $6, $7)
returning id, media_file_id, import_task_id, method, source_path, dest_path, attempted_at, success, error_message
`

type CreateMediaFileImportParams struct {
	MediaFileID  pgtype.UUID `json:"media_file_id"`
	ImportTaskID pgtype.UUID `json:"import_task_id"`
	Method       string      `json:"method"`
	SourcePath   *string     `json:"source_path"`
	DestPath     string      `json:"dest_path"`
	Success      bool        `json:"success"`
	ErrorMessage *string     `json:"error_message"`
}

// Media File Import queries
func (q *Queries) CreateMediaFileImport(ctx context.Context, arg CreateMediaFileImportParams) (MediaFileImport, error) {
	row := q.db.QueryRow(ctx, createMediaFileImport,
		arg.MediaFileID,
		arg.ImportTaskID,
		arg.Method,
		arg.SourcePath,
		arg.DestPath,
		arg.Success,
		arg.ErrorMessage,
	)
	var i MediaFileImport
	err := row.Scan(
		&i.ID,
		&i.MediaFileID,
		&i.ImportTaskID,
		&i.Method,
		&i.SourcePath,
		&i.DestPath,
		&i.AttemptedAt,
		&i.Success,
		&i.ErrorMessage,
	)
	return i, err
}

const createMediaFileState = `-- name: CreateMediaFileState :one

insert into media_file_state (media_file_id, file_exists, file_size, last_verified_at)
values ($1, $2, $3, now())
returning media_file_id, file_exists, file_size, last_verified_at
`

type CreateMediaFileStateParams struct {
	MediaFileID pgtype.UUID `json:"media_file_id"`
	FileExists  bool        `json:"file_exists"`
	FileSize    *int64      `json:"file_size"`
}

// Media File State queries
func (q *Queries) CreateMediaFileState(ctx context.Context, arg CreateMediaFileStateParams) (MediaFileState, error) {
	row := q.db.QueryRow(ctx, createMediaFileState, arg.MediaFileID, arg.FileExists, arg.FileSize)
	var i MediaFileState
	err := row.Scan(
		&i.MediaFileID,
		&i.FileExists,
		&i.FileSize,
		&i.LastVerifiedAt,
	)
	return i, err
}

const createMediaItem = `-- name: CreateMediaItem :one
insert into media_item (type, title, year, tmdb_id)
values ($1, $2, $3, $4)
returning id, type, title, year, tmdb_id, created_at, updated_at
`

type CreateMediaItemParams struct {
	Type   string `json:"type"`
	Title  string `json:"title"`
	Year   *int32 `json:"year"`
	TmdbID *int64 `json:"tmdb_id"`
}

func (q *Queries) CreateMediaItem(ctx context.Context, arg CreateMediaItemParams) (MediaItem, error) {
	row := q.db.QueryRow(ctx, createMediaItem,
		arg.Type,
		arg.Title,
		arg.Year,
		arg.TmdbID,
	)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Title,
		&i.Year,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUnmatchedFile = `-- name: CreateUnmatchedFile :one

insert into unmatched_file (library_id, path, file_size, suggested_matches)
values ($1, $2, $3, $4)
returning id, library_id, path, file_size, discovered_at, suggested_matches, resolved_at, resolved_media_file_id
`

type CreateUnmatchedFileParams struct {
	LibraryID        pgtype.UUID `json:"library_id"`
	Path             string      `json:"path"`
	FileSize         *int64      `json:"file_size"`
	SuggestedMatches []byte      `json:"suggested_matches"`
}

// Unmatched File queries
func (q *Queries) CreateUnmatchedFile(ctx context.Context, arg CreateUnmatchedFileParams) (UnmatchedFile, error) {
	row := q.db.QueryRow(ctx, createUnmatchedFile,
		arg.LibraryID,
		arg.Path,
		arg.FileSize,
		arg.SuggestedMatches,
	)
	var i UnmatchedFile
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Path,
		&i.FileSize,
		&i.DiscoveredAt,
		&i.SuggestedMatches,
		&i.ResolvedAt,
		&i.ResolvedMediaFileID,
	)
	return i, err
}

const deleteMediaFile = `-- name: DeleteMediaFile :exec
delete from media_file where id = $1
`

func (q *Queries) DeleteMediaFile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMediaFile, id)
	return err
}

const deleteMediaItem = `-- name: DeleteMediaItem :exec
delete from media_item where id = $1
`

func (q *Queries) DeleteMediaItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMediaItem, id)
	return err
}

const deleteResolvedUnmatchedFilesOlderThan = `-- name: DeleteResolvedUnmatchedFilesOlderThan :exec
delete from unmatched_file
where resolved_at is not null
  and resolved_at < $1
`

func (q *Queries) DeleteResolvedUnmatchedFilesOlderThan(ctx context.Context, beforeTime pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteResolvedUnmatchedFilesOlderThan, beforeTime)
	return err
}

const deleteUnmatchedFile = `-- name: DeleteUnmatchedFile :exec
delete from unmatched_file where id = $1
`

func (q *Queries) DeleteUnmatchedFile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUnmatchedFile, id)
	return err
}

const dismissUnmatchedFile = `-- name: DismissUnmatchedFile :one
update unmatched_file
set resolved_at = now()
where id = $1
returning id, library_id, path, file_size, discovered_at, suggested_matches, resolved_at, resolved_media_file_id
`

func (q *Queries) DismissUnmatchedFile(ctx context.Context, id pgtype.UUID) (UnmatchedFile, error) {
	row := q.db.QueryRow(ctx, dismissUnmatchedFile, id)
	var i UnmatchedFile
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Path,
		&i.FileSize,
		&i.DiscoveredAt,
		&i.SuggestedMatches,
		&i.ResolvedAt,
		&i.ResolvedMediaFileID,
	)
	return i, err
}

const getEpisode = `-- name: GetEpisode :one
select id, season_id, episode_number, title, air_date, tmdb_id, tvdb_id, created_at from media_episode
where id = $1
`

func (q *Queries) GetEpisode(ctx context.Context, id pgtype.UUID) (MediaEpisode, error) {
	row := q.db.QueryRow(ctx, getEpisode, id)
	var i MediaEpisode
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.EpisodeNumber,
		&i.Title,
		&i.AirDate,
		&i.TmdbID,
		&i.TvdbID,
		&i.CreatedAt,
	)
	return i, err
}

const getEpisodeByNumber = `-- name: GetEpisodeByNumber :one
select id, season_id, episode_number, title, air_date, tmdb_id, tvdb_id, created_at from media_episode
where season_id = $1 and episode_number = $2
`

type GetEpisodeByNumberParams struct {
	SeasonID      pgtype.UUID `json:"season_id"`
	EpisodeNumber int32       `json:"episode_number"`
}

func (q *Queries) GetEpisodeByNumber(ctx context.Context, arg GetEpisodeByNumberParams) (MediaEpisode, error) {
	row := q.db.QueryRow(ctx, getEpisodeByNumber, arg.SeasonID, arg.EpisodeNumber)
	var i MediaEpisode
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.EpisodeNumber,
		&i.Title,
		&i.AirDate,
		&i.TmdbID,
		&i.TvdbID,
		&i.CreatedAt,
	)
	return i, err
}

const getMediaFile = `-- name: GetMediaFile :one

select id, library_id, media_item_id, episode_id, path, created_at from media_file where id = $1
`

// Files (removed season_id and status)
func (q *Queries) GetMediaFile(ctx context.Context, id pgtype.UUID) (MediaFile, error) {
	row := q.db.QueryRow(ctx, getMediaFile, id)
	var i MediaFile
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.MediaItemID,
		&i.EpisodeID,
		&i.Path,
		&i.CreatedAt,
	)
	return i, err
}

const getMediaFileByLibraryAndPath = `-- name: GetMediaFileByLibraryAndPath :one
select id, library_id, media_item_id, episode_id, path, created_at from media_file where library_id = $1 and path = $2
`

type GetMediaFileByLibraryAndPathParams struct {
	LibraryID pgtype.UUID `json:"library_id"`
	Path      string      `json:"path"`
}

func (q *Queries) GetMediaFileByLibraryAndPath(ctx context.Context, arg GetMediaFileByLibraryAndPathParams) (MediaFile, error) {
	row := q.db.QueryRow(ctx, getMediaFileByLibraryAndPath, arg.LibraryID, arg.Path)
	var i MediaFile
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.MediaItemID,
		&i.EpisodeID,
		&i.Path,
		&i.CreatedAt,
	)
	return i, err
}

const getMediaFileImport = `-- name: GetMediaFileImport :one
select id, media_file_id, import_task_id, method, source_path, dest_path, attempted_at, success, error_message from media_file_import where id = $1
`

func (q *Queries) GetMediaFileImport(ctx context.Context, id pgtype.UUID) (MediaFileImport, error) {
	row := q.db.QueryRow(ctx, getMediaFileImport, id)
	var i MediaFileImport
	err := row.Scan(
		&i.ID,
		&i.MediaFileID,
		&i.ImportTaskID,
		&i.Method,
		&i.SourcePath,
		&i.DestPath,
		&i.AttemptedAt,
		&i.Success,
		&i.ErrorMessage,
	)
	return i, err
}

const getMediaFileState = `-- name: GetMediaFileState :one
select media_file_id, file_exists, file_size, last_verified_at from media_file_state where media_file_id = $1
`

func (q *Queries) GetMediaFileState(ctx context.Context, mediaFileID pgtype.UUID) (MediaFileState, error) {
	row := q.db.QueryRow(ctx, getMediaFileState, mediaFileID)
	var i MediaFileState
	err := row.Scan(
		&i.MediaFileID,
		&i.FileExists,
		&i.FileSize,
		&i.LastVerifiedAt,
	)
	return i, err
}

const getMediaItem = `-- name: GetMediaItem :one
select id, type, title, year, tmdb_id, created_at, updated_at from media_item
where id = $1
`

func (q *Queries) GetMediaItem(ctx context.Context, id pgtype.UUID) (MediaItem, error) {
	row := q.db.QueryRow(ctx, getMediaItem, id)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Title,
		&i.Year,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMediaItemByTmdbID = `-- name: GetMediaItemByTmdbID :one
select id, type, title, year, tmdb_id, created_at, updated_at from media_item
where tmdb_id = $1
`

func (q *Queries) GetMediaItemByTmdbID(ctx context.Context, tmdbID *int64) (MediaItem, error) {
	row := q.db.QueryRow(ctx, getMediaItemByTmdbID, tmdbID)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Title,
		&i.Year,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMediaItemByTmdbIDAndType = `-- name: GetMediaItemByTmdbIDAndType :one
select id, type, title, year, tmdb_id, created_at, updated_at from media_item
where tmdb_id = $1 and type = $2
`

type GetMediaItemByTmdbIDAndTypeParams struct {
	TmdbID *int64 `json:"tmdb_id"`
	Type   string `json:"type"`
}

func (q *Queries) GetMediaItemByTmdbIDAndType(ctx context.Context, arg GetMediaItemByTmdbIDAndTypeParams) (MediaItem, error) {
	row := q.db.QueryRow(ctx, getMediaItemByTmdbIDAndType, arg.TmdbID, arg.Type)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Title,
		&i.Year,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMediaItemsByTmdbIDs = `-- name: GetMediaItemsByTmdbIDs :many
SELECT tmdb_id FROM media_item
WHERE tmdb_id = ANY($1::bigint[]) AND type = $2
`

type GetMediaItemsByTmdbIDsParams struct {
	TmdbIds []int64 `json:"tmdb_ids"`
	Type    string  `json:"type"`
}

func (q *Queries) GetMediaItemsByTmdbIDs(ctx context.Context, arg GetMediaItemsByTmdbIDsParams) ([]*int64, error) {
	rows, err := q.db.Query(ctx, getMediaItemsByTmdbIDs, arg.TmdbIds, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*int64
	for rows.Next() {
		var tmdb_id *int64
		if err := rows.Scan(&tmdb_id); err != nil {
			return nil, err
		}
		items = append(items, tmdb_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeason = `-- name: GetSeason :one
select id, media_item_id, season_number, air_date, created_at from media_season
where id = $1
`

func (q *Queries) GetSeason(ctx context.Context, id pgtype.UUID) (MediaSeason, error) {
	row := q.db.QueryRow(ctx, getSeason, id)
	var i MediaSeason
	err := row.Scan(
		&i.ID,
		&i.MediaItemID,
		&i.SeasonNumber,
		&i.AirDate,
		&i.CreatedAt,
	)
	return i, err
}

const getSeasonByNumber = `-- name: GetSeasonByNumber :one
select id, media_item_id, season_number, air_date, created_at from media_season
where media_item_id = $1 and season_number = $2
`

type GetSeasonByNumberParams struct {
	MediaItemID  pgtype.UUID `json:"media_item_id"`
	SeasonNumber int32       `json:"season_number"`
}

func (q *Queries) GetSeasonByNumber(ctx context.Context, arg GetSeasonByNumberParams) (MediaSeason, error) {
	row := q.db.QueryRow(ctx, getSeasonByNumber, arg.MediaItemID, arg.SeasonNumber)
	var i MediaSeason
	err := row.Scan(
		&i.ID,
		&i.MediaItemID,
		&i.SeasonNumber,
		&i.AirDate,
		&i.CreatedAt,
	)
	return i, err
}

const getUnmatchedFile = `-- name: GetUnmatchedFile :one
select id, library_id, path, file_size, discovered_at, suggested_matches, resolved_at, resolved_media_file_id from unmatched_file where id = $1
`

func (q *Queries) GetUnmatchedFile(ctx context.Context, id pgtype.UUID) (UnmatchedFile, error) {
	row := q.db.QueryRow(ctx, getUnmatchedFile, id)
	var i UnmatchedFile
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Path,
		&i.FileSize,
		&i.DiscoveredAt,
		&i.SuggestedMatches,
		&i.ResolvedAt,
		&i.ResolvedMediaFileID,
	)
	return i, err
}

const getUnmatchedFileByPath = `-- name: GetUnmatchedFileByPath :one
select id, library_id, path, file_size, discovered_at, suggested_matches, resolved_at, resolved_media_file_id from unmatched_file where library_id = $1 and path = $2
`

type GetUnmatchedFileByPathParams struct {
	LibraryID pgtype.UUID `json:"library_id"`
	Path      string      `json:"path"`
}

func (q *Queries) GetUnmatchedFileByPath(ctx context.Context, arg GetUnmatchedFileByPathParams) (UnmatchedFile, error) {
	row := q.db.QueryRow(ctx, getUnmatchedFileByPath, arg.LibraryID, arg.Path)
	var i UnmatchedFile
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Path,
		&i.FileSize,
		&i.DiscoveredAt,
		&i.SuggestedMatches,
		&i.ResolvedAt,
		&i.ResolvedMediaFileID,
	)
	return i, err
}

const listEpisodeAvailabilityForSeries = `-- name: ListEpisodeAvailabilityForSeries :many
select
  ms.season_number,
  me.episode_number,
  me.id as episode_id,
  me.title,
  me.air_date,
  mf.id as file_id,
  mf.library_id,
  mfs.file_exists
from media_episode me
join media_season ms on me.season_id = ms.id
join media_item mi on ms.media_item_id = mi.id
left join media_file mf on mf.episode_id = me.id
left join media_file_state mfs on mf.id = mfs.media_file_id
where mi.id = $1
order by ms.season_number, me.episode_number
`

type ListEpisodeAvailabilityForSeriesRow struct {
	SeasonNumber  int32       `json:"season_number"`
	EpisodeNumber int32       `json:"episode_number"`
	EpisodeID     pgtype.UUID `json:"episode_id"`
	Title         *string     `json:"title"`
	AirDate       pgtype.Date `json:"air_date"`
	FileID        pgtype.UUID `json:"file_id"`
	LibraryID     pgtype.UUID `json:"library_id"`
	FileExists    *bool       `json:"file_exists"`
}

func (q *Queries) ListEpisodeAvailabilityForSeries(ctx context.Context, id pgtype.UUID) ([]ListEpisodeAvailabilityForSeriesRow, error) {
	rows, err := q.db.Query(ctx, listEpisodeAvailabilityForSeries, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEpisodeAvailabilityForSeriesRow
	for rows.Next() {
		var i ListEpisodeAvailabilityForSeriesRow
		if err := rows.Scan(
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.EpisodeID,
			&i.Title,
			&i.AirDate,
			&i.FileID,
			&i.LibraryID,
			&i.FileExists,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesForSeason = `-- name: ListEpisodesForSeason :many

select id, season_id, episode_number, title, air_date, tmdb_id, tvdb_id, created_at from media_episode
where season_id = $1
order by episode_number asc
`

// Episodes
func (q *Queries) ListEpisodesForSeason(ctx context.Context, seasonID pgtype.UUID) ([]MediaEpisode, error) {
	rows, err := q.db.Query(ctx, listEpisodesForSeason, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaEpisode
	for rows.Next() {
		var i MediaEpisode
		if err := rows.Scan(
			&i.ID,
			&i.SeasonID,
			&i.EpisodeNumber,
			&i.Title,
			&i.AirDate,
			&i.TmdbID,
			&i.TvdbID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailedImports = `-- name: ListFailedImports :many
select id, media_file_id, import_task_id, method, source_path, dest_path, attempted_at, success, error_message from media_file_import
where success = false
order by attempted_at desc
limit $1
`

func (q *Queries) ListFailedImports(ctx context.Context, limitVal int32) ([]MediaFileImport, error) {
	rows, err := q.db.Query(ctx, listFailedImports, limitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaFileImport
	for rows.Next() {
		var i MediaFileImport
		if err := rows.Scan(
			&i.ID,
			&i.MediaFileID,
			&i.ImportTaskID,
			&i.Method,
			&i.SourcePath,
			&i.DestPath,
			&i.AttemptedAt,
			&i.Success,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesNeedingVerification = `-- name: ListFilesNeedingVerification :many
select mf.id, mf.library_id, mf.media_item_id, mf.episode_id, mf.path, mf.created_at, mfs.file_exists, mfs.file_size, mfs.last_verified_at
from media_file mf
join media_file_state mfs on mf.id = mfs.media_file_id
where mfs.last_verified_at < $1
order by mfs.last_verified_at asc
limit $2
`

type ListFilesNeedingVerificationParams struct {
	BeforeTime time.Time `json:"before_time"`
	LimitVal   int32     `json:"limit_val"`
}

type ListFilesNeedingVerificationRow struct {
	ID             pgtype.UUID `json:"id"`
	LibraryID      pgtype.UUID `json:"library_id"`
	MediaItemID    pgtype.UUID `json:"media_item_id"`
	EpisodeID      pgtype.UUID `json:"episode_id"`
	Path           string      `json:"path"`
	CreatedAt      time.Time   `json:"created_at"`
	FileExists     bool        `json:"file_exists"`
	FileSize       *int64      `json:"file_size"`
	LastVerifiedAt time.Time   `json:"last_verified_at"`
}

func (q *Queries) ListFilesNeedingVerification(ctx context.Context, arg ListFilesNeedingVerificationParams) ([]ListFilesNeedingVerificationRow, error) {
	rows, err := q.db.Query(ctx, listFilesNeedingVerification, arg.BeforeTime, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFilesNeedingVerificationRow
	for rows.Next() {
		var i ListFilesNeedingVerificationRow
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.MediaItemID,
			&i.EpisodeID,
			&i.Path,
			&i.CreatedAt,
			&i.FileExists,
			&i.FileSize,
			&i.LastVerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImportsForImportTask = `-- name: ListImportsForImportTask :many
select id, media_file_id, import_task_id, method, source_path, dest_path, attempted_at, success, error_message from media_file_import
where import_task_id = $1
order by attempted_at desc
`

func (q *Queries) ListImportsForImportTask(ctx context.Context, importTaskID pgtype.UUID) ([]MediaFileImport, error) {
	rows, err := q.db.Query(ctx, listImportsForImportTask, importTaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaFileImport
	for rows.Next() {
		var i MediaFileImport
		if err := rows.Scan(
			&i.ID,
			&i.MediaFileID,
			&i.ImportTaskID,
			&i.Method,
			&i.SourcePath,
			&i.DestPath,
			&i.AttemptedAt,
			&i.Success,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImportsForMediaFile = `-- name: ListImportsForMediaFile :many
select id, media_file_id, import_task_id, method, source_path, dest_path, attempted_at, success, error_message from media_file_import
where media_file_id = $1
order by attempted_at desc
`

func (q *Queries) ListImportsForMediaFile(ctx context.Context, mediaFileID pgtype.UUID) ([]MediaFileImport, error) {
	rows, err := q.db.Query(ctx, listImportsForMediaFile, mediaFileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaFileImport
	for rows.Next() {
		var i MediaFileImport
		if err := rows.Scan(
			&i.ID,
			&i.MediaFileID,
			&i.ImportTaskID,
			&i.Method,
			&i.SourcePath,
			&i.DestPath,
			&i.AttemptedAt,
			&i.Success,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaFilesForItem = `-- name: ListMediaFilesForItem :many
select
  mf.id,
  mf.library_id,
  mf.media_item_id,
  mf.episode_id,
  mf.path,
  mf.created_at,
  ms.id as season_id,
  ms.season_number,
  me.episode_number,
  mfs.file_exists,
  mfs.file_size,
  mfs.last_verified_at
from media_file mf
left join media_episode me on mf.episode_id = me.id
left join media_season ms on me.season_id = ms.id
left join media_file_state mfs on mf.id = mfs.media_file_id
where mf.media_item_id = $1
order by mf.created_at desc
`

type ListMediaFilesForItemRow struct {
	ID             pgtype.UUID        `json:"id"`
	LibraryID      pgtype.UUID        `json:"library_id"`
	MediaItemID    pgtype.UUID        `json:"media_item_id"`
	EpisodeID      pgtype.UUID        `json:"episode_id"`
	Path           string             `json:"path"`
	CreatedAt      time.Time          `json:"created_at"`
	SeasonID       pgtype.UUID        `json:"season_id"`
	SeasonNumber   *int32             `json:"season_number"`
	EpisodeNumber  *int32             `json:"episode_number"`
	FileExists     *bool              `json:"file_exists"`
	FileSize       *int64             `json:"file_size"`
	LastVerifiedAt pgtype.Timestamptz `json:"last_verified_at"`
}

func (q *Queries) ListMediaFilesForItem(ctx context.Context, mediaItemID pgtype.UUID) ([]ListMediaFilesForItemRow, error) {
	rows, err := q.db.Query(ctx, listMediaFilesForItem, mediaItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMediaFilesForItemRow
	for rows.Next() {
		var i ListMediaFilesForItemRow
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.MediaItemID,
			&i.EpisodeID,
			&i.Path,
			&i.CreatedAt,
			&i.SeasonID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.FileExists,
			&i.FileSize,
			&i.LastVerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaItems = `-- name: ListMediaItems :many

select id, type, title, year, tmdb_id, created_at, updated_at from media_item
order by created_at desc
`

// Media queries
func (q *Queries) ListMediaItems(ctx context.Context) ([]MediaItem, error) {
	rows, err := q.db.Query(ctx, listMediaItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaItem
	for rows.Next() {
		var i MediaItem
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Title,
			&i.Year,
			&i.TmdbID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaItemsPaginated = `-- name: ListMediaItemsPaginated :many

SELECT id, type, title, year, tmdb_id, created_at, updated_at FROM media_item
WHERE
    ($1::text IS NULL OR type = $1) AND
    ($2::text IS NULL OR title ILIKE '%' || $2 || '%')
ORDER BY
    CASE WHEN $3::text = 'title' AND $4::text = 'asc' THEN title END ASC,
    CASE WHEN $3::text = 'title' AND $4::text = 'desc' THEN title END DESC,
    CASE WHEN $3::text = 'year' AND $4::text = 'asc' THEN year END ASC NULLS LAST,
    CASE WHEN $3::text = 'year' AND $4::text = 'desc' THEN year END DESC NULLS LAST,
    CASE WHEN $3::text = 'createdAt' AND $4::text = 'asc' THEN created_at END ASC,
    CASE WHEN $3::text = 'createdAt' AND $4::text = 'desc' THEN created_at END DESC,
    created_at DESC
LIMIT $6::int OFFSET $5::int
`

type ListMediaItemsPaginatedParams struct {
	TypeFilter *string `json:"type_filter"`
	Search     *string `json:"search"`
	SortBy     string  `json:"sort_by"`
	SortDir    string  `json:"sort_dir"`
	OffsetVal  int32   `json:"offset_val"`
	PageSize   int32   `json:"page_size"`
}

// Paginated library queries
func (q *Queries) ListMediaItemsPaginated(ctx context.Context, arg ListMediaItemsPaginatedParams) ([]MediaItem, error) {
	rows, err := q.db.Query(ctx, listMediaItemsPaginated,
		arg.TypeFilter,
		arg.Search,
		arg.SortBy,
		arg.SortDir,
		arg.OffsetVal,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaItem
	for rows.Next() {
		var i MediaItem
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Title,
			&i.Year,
			&i.TmdbID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMissingFiles = `-- name: ListMissingFiles :many
select mf.id, mf.library_id, mf.media_item_id, mf.episode_id, mf.path, mf.created_at, mfs.file_size, mfs.last_verified_at
from media_file mf
join media_file_state mfs on mf.id = mfs.media_file_id
where mfs.file_exists = false
order by mfs.last_verified_at desc
`

type ListMissingFilesRow struct {
	ID             pgtype.UUID `json:"id"`
	LibraryID      pgtype.UUID `json:"library_id"`
	MediaItemID    pgtype.UUID `json:"media_item_id"`
	EpisodeID      pgtype.UUID `json:"episode_id"`
	Path           string      `json:"path"`
	CreatedAt      time.Time   `json:"created_at"`
	FileSize       *int64      `json:"file_size"`
	LastVerifiedAt time.Time   `json:"last_verified_at"`
}

func (q *Queries) ListMissingFiles(ctx context.Context) ([]ListMissingFilesRow, error) {
	rows, err := q.db.Query(ctx, listMissingFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMissingFilesRow
	for rows.Next() {
		var i ListMissingFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.MediaItemID,
			&i.EpisodeID,
			&i.Path,
			&i.CreatedAt,
			&i.FileSize,
			&i.LastVerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentImports = `-- name: ListRecentImports :many
select id, media_file_id, import_task_id, method, source_path, dest_path, attempted_at, success, error_message from media_file_import
order by attempted_at desc
limit $1
`

func (q *Queries) ListRecentImports(ctx context.Context, limitVal int32) ([]MediaFileImport, error) {
	rows, err := q.db.Query(ctx, listRecentImports, limitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaFileImport
	for rows.Next() {
		var i MediaFileImport
		if err := rows.Scan(
			&i.ID,
			&i.MediaFileID,
			&i.ImportTaskID,
			&i.Method,
			&i.SourcePath,
			&i.DestPath,
			&i.AttemptedAt,
			&i.Success,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeasonsForMedia = `-- name: ListSeasonsForMedia :many

select id, media_item_id, season_number, air_date, created_at from media_season
where media_item_id = $1
order by season_number asc
`

// Seasons
func (q *Queries) ListSeasonsForMedia(ctx context.Context, mediaItemID pgtype.UUID) ([]MediaSeason, error) {
	rows, err := q.db.Query(ctx, listSeasonsForMedia, mediaItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaSeason
	for rows.Next() {
		var i MediaSeason
		if err := rows.Scan(
			&i.ID,
			&i.MediaItemID,
			&i.SeasonNumber,
			&i.AirDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedFiles = `-- name: ListUnmatchedFiles :many
select id, library_id, path, file_size, discovered_at, suggested_matches, resolved_at, resolved_media_file_id from unmatched_file
where resolved_at is null
order by discovered_at desc
`

func (q *Queries) ListUnmatchedFiles(ctx context.Context) ([]UnmatchedFile, error) {
	rows, err := q.db.Query(ctx, listUnmatchedFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnmatchedFile
	for rows.Next() {
		var i UnmatchedFile
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.Path,
			&i.FileSize,
			&i.DiscoveredAt,
			&i.SuggestedMatches,
			&i.ResolvedAt,
			&i.ResolvedMediaFileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedFilesForLibrary = `-- name: ListUnmatchedFilesForLibrary :many
select id, library_id, path, file_size, discovered_at, suggested_matches, resolved_at, resolved_media_file_id from unmatched_file
where library_id = $1 and resolved_at is null
order by discovered_at desc
`

func (q *Queries) ListUnmatchedFilesForLibrary(ctx context.Context, libraryID pgtype.UUID) ([]UnmatchedFile, error) {
	rows, err := q.db.Query(ctx, listUnmatchedFilesForLibrary, libraryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnmatchedFile
	for rows.Next() {
		var i UnmatchedFile
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.Path,
			&i.FileSize,
			&i.DiscoveredAt,
			&i.SuggestedMatches,
			&i.ResolvedAt,
			&i.ResolvedMediaFileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedFilesPaginated = `-- name: ListUnmatchedFilesPaginated :many
select id, library_id, path, file_size, discovered_at, suggested_matches, resolved_at, resolved_media_file_id from unmatched_file
where resolved_at is null
  and ($1::uuid is null or library_id = $1)
order by discovered_at desc
limit $3::int offset $2::int
`

type ListUnmatchedFilesPaginatedParams struct {
	LibraryID pgtype.UUID `json:"library_id"`
	OffsetVal int32       `json:"offset_val"`
	PageSize  int32       `json:"page_size"`
}

func (q *Queries) ListUnmatchedFilesPaginated(ctx context.Context, arg ListUnmatchedFilesPaginatedParams) ([]UnmatchedFile, error) {
	rows, err := q.db.Query(ctx, listUnmatchedFilesPaginated, arg.LibraryID, arg.OffsetVal, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnmatchedFile
	for rows.Next() {
		var i UnmatchedFile
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.Path,
			&i.FileSize,
			&i.DiscoveredAt,
			&i.SuggestedMatches,
			&i.ResolvedAt,
			&i.ResolvedMediaFileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveUnmatchedFile = `-- name: ResolveUnmatchedFile :one
update unmatched_file
set resolved_at = now(),
    resolved_media_file_id = $1
where id = $2
returning id, library_id, path, file_size, discovered_at, suggested_matches, resolved_at, resolved_media_file_id
`

type ResolveUnmatchedFileParams struct {
	ResolvedMediaFileID pgtype.UUID `json:"resolved_media_file_id"`
	ID                  pgtype.UUID `json:"id"`
}

func (q *Queries) ResolveUnmatchedFile(ctx context.Context, arg ResolveUnmatchedFileParams) (UnmatchedFile, error) {
	row := q.db.QueryRow(ctx, resolveUnmatchedFile, arg.ResolvedMediaFileID, arg.ID)
	var i UnmatchedFile
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Path,
		&i.FileSize,
		&i.DiscoveredAt,
		&i.SuggestedMatches,
		&i.ResolvedAt,
		&i.ResolvedMediaFileID,
	)
	return i, err
}

const updateMediaFileState = `-- name: UpdateMediaFileState :one
update media_file_state
set file_exists = $1,
    file_size = $2,
    last_verified_at = now()
where media_file_id = $3
returning media_file_id, file_exists, file_size, last_verified_at
`

type UpdateMediaFileStateParams struct {
	FileExists  bool        `json:"file_exists"`
	FileSize    *int64      `json:"file_size"`
	MediaFileID pgtype.UUID `json:"media_file_id"`
}

func (q *Queries) UpdateMediaFileState(ctx context.Context, arg UpdateMediaFileStateParams) (MediaFileState, error) {
	row := q.db.QueryRow(ctx, updateMediaFileState, arg.FileExists, arg.FileSize, arg.MediaFileID)
	var i MediaFileState
	err := row.Scan(
		&i.MediaFileID,
		&i.FileExists,
		&i.FileSize,
		&i.LastVerifiedAt,
	)
	return i, err
}

const updateMediaItem = `-- name: UpdateMediaItem :one
update media_item
set title = $2,
    year = $3,
    tmdb_id = $4,
    updated_at = now()
where id = $1
returning id, type, title, year, tmdb_id, created_at, updated_at
`

type UpdateMediaItemParams struct {
	ID     pgtype.UUID `json:"id"`
	Title  string      `json:"title"`
	Year   *int32      `json:"year"`
	TmdbID *int64      `json:"tmdb_id"`
}

func (q *Queries) UpdateMediaItem(ctx context.Context, arg UpdateMediaItemParams) (MediaItem, error) {
	row := q.db.QueryRow(ctx, updateMediaItem,
		arg.ID,
		arg.Title,
		arg.Year,
		arg.TmdbID,
	)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Title,
		&i.Year,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUnmatchedFileSuggestions = `-- name: UpdateUnmatchedFileSuggestions :one
update unmatched_file
set suggested_matches = $1
where id = $2
returning id, library_id, path, file_size, discovered_at, suggested_matches, resolved_at, resolved_media_file_id
`

type UpdateUnmatchedFileSuggestionsParams struct {
	SuggestedMatches []byte      `json:"suggested_matches"`
	ID               pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateUnmatchedFileSuggestions(ctx context.Context, arg UpdateUnmatchedFileSuggestionsParams) (UnmatchedFile, error) {
	row := q.db.QueryRow(ctx, updateUnmatchedFileSuggestions, arg.SuggestedMatches, arg.ID)
	var i UnmatchedFile
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Path,
		&i.FileSize,
		&i.DiscoveredAt,
		&i.SuggestedMatches,
		&i.ResolvedAt,
		&i.ResolvedMediaFileID,
	)
	return i, err
}

const upsertEpisode = `-- name: UpsertEpisode :one
insert into media_episode (season_id, episode_number, title, air_date, tmdb_id, tvdb_id)
values ($1, $2, $3, $4, $5, $6)
on conflict (season_id, episode_number)
do update set title = excluded.title,
              air_date = excluded.air_date,
              tmdb_id = excluded.tmdb_id,
              tvdb_id = excluded.tvdb_id
returning id, season_id, episode_number, title, air_date, tmdb_id, tvdb_id, created_at
`

type UpsertEpisodeParams struct {
	SeasonID      pgtype.UUID `json:"season_id"`
	EpisodeNumber int32       `json:"episode_number"`
	Title         *string     `json:"title"`
	AirDate       pgtype.Date `json:"air_date"`
	TmdbID        *int64      `json:"tmdb_id"`
	TvdbID        *int64      `json:"tvdb_id"`
}

func (q *Queries) UpsertEpisode(ctx context.Context, arg UpsertEpisodeParams) (MediaEpisode, error) {
	row := q.db.QueryRow(ctx, upsertEpisode,
		arg.SeasonID,
		arg.EpisodeNumber,
		arg.Title,
		arg.AirDate,
		arg.TmdbID,
		arg.TvdbID,
	)
	var i MediaEpisode
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.EpisodeNumber,
		&i.Title,
		&i.AirDate,
		&i.TmdbID,
		&i.TvdbID,
		&i.CreatedAt,
	)
	return i, err
}

const upsertMediaFileState = `-- name: UpsertMediaFileState :one
insert into media_file_state (media_file_id, file_exists, file_size, last_verified_at)
values ($1, $2, $3, now())
on conflict (media_file_id)
do update set file_exists = excluded.file_exists,
              file_size = excluded.file_size,
              last_verified_at = now()
returning media_file_id, file_exists, file_size, last_verified_at
`

type UpsertMediaFileStateParams struct {
	MediaFileID pgtype.UUID `json:"media_file_id"`
	FileExists  bool        `json:"file_exists"`
	FileSize    *int64      `json:"file_size"`
}

func (q *Queries) UpsertMediaFileState(ctx context.Context, arg UpsertMediaFileStateParams) (MediaFileState, error) {
	row := q.db.QueryRow(ctx, upsertMediaFileState, arg.MediaFileID, arg.FileExists, arg.FileSize)
	var i MediaFileState
	err := row.Scan(
		&i.MediaFileID,
		&i.FileExists,
		&i.FileSize,
		&i.LastVerifiedAt,
	)
	return i, err
}

const upsertMediaItem = `-- name: UpsertMediaItem :one
insert into media_item (type, title, year, tmdb_id)
values ($1, $2, $3, $4)
on conflict (type, tmdb_id)
do update set title = excluded.title,
              year = excluded.year,
              updated_at = now()
returning id, type, title, year, tmdb_id, created_at, updated_at
`

type UpsertMediaItemParams struct {
	Type   string `json:"type"`
	Title  string `json:"title"`
	Year   *int32 `json:"year"`
	TmdbID *int64 `json:"tmdb_id"`
}

func (q *Queries) UpsertMediaItem(ctx context.Context, arg UpsertMediaItemParams) (MediaItem, error) {
	row := q.db.QueryRow(ctx, upsertMediaItem,
		arg.Type,
		arg.Title,
		arg.Year,
		arg.TmdbID,
	)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Title,
		&i.Year,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertSeason = `-- name: UpsertSeason :one
insert into media_season (media_item_id, season_number, air_date)
values ($1, $2, $3)
on conflict (media_item_id, season_number)
do update set air_date = excluded.air_date
returning id, media_item_id, season_number, air_date, created_at
`

type UpsertSeasonParams struct {
	MediaItemID  pgtype.UUID `json:"media_item_id"`
	SeasonNumber int32       `json:"season_number"`
	AirDate      pgtype.Date `json:"air_date"`
}

func (q *Queries) UpsertSeason(ctx context.Context, arg UpsertSeasonParams) (MediaSeason, error) {
	row := q.db.QueryRow(ctx, upsertSeason, arg.MediaItemID, arg.SeasonNumber, arg.AirDate)
	var i MediaSeason
	err := row.Scan(
		&i.ID,
		&i.MediaItemID,
		&i.SeasonNumber,
		&i.AirDate,
		&i.CreatedAt,
	)
	return i, err
}

const upsertUnmatchedFile = `-- name: UpsertUnmatchedFile :one
insert into unmatched_file (library_id, path, file_size, suggested_matches)
values ($1, $2, $3, $4)
on conflict (library_id, path)
do update set file_size = excluded.file_size,
              suggested_matches = excluded.suggested_matches,
              discovered_at = now()
returning id, library_id, path, file_size, discovered_at, suggested_matches, resolved_at, resolved_media_file_id
`

type UpsertUnmatchedFileParams struct {
	LibraryID        pgtype.UUID `json:"library_id"`
	Path             string      `json:"path"`
	FileSize         *int64      `json:"file_size"`
	SuggestedMatches []byte      `json:"suggested_matches"`
}

func (q *Queries) UpsertUnmatchedFile(ctx context.Context, arg UpsertUnmatchedFileParams) (UnmatchedFile, error) {
	row := q.db.QueryRow(ctx, upsertUnmatchedFile,
		arg.LibraryID,
		arg.Path,
		arg.FileSize,
		arg.SuggestedMatches,
	)
	var i UnmatchedFile
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Path,
		&i.FileSize,
		&i.DiscoveredAt,
		&i.SuggestedMatches,
		&i.ResolvedAt,
		&i.ResolvedMediaFileID,
	)
	return i, err
}
