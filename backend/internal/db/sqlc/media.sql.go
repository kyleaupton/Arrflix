// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: media.sql

package dbgen

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMediaFile = `-- name: CreateMediaFile :one
insert into media_file (library_id, media_item_id, season_id, episode_id, path, status)
values ($1, $2, $3, $4, $5, coalesce($6, 'available'))
returning id, library_id, media_item_id, season_id, episode_id, path, status, added_at
`

type CreateMediaFileParams struct {
	LibraryID   pgtype.UUID `json:"library_id"`
	MediaItemID pgtype.UUID `json:"media_item_id"`
	SeasonID    pgtype.UUID `json:"season_id"`
	EpisodeID   pgtype.UUID `json:"episode_id"`
	Path        string      `json:"path"`
	Status      interface{} `json:"status"`
}

func (q *Queries) CreateMediaFile(ctx context.Context, arg CreateMediaFileParams) (MediaFile, error) {
	row := q.db.QueryRow(ctx, createMediaFile,
		arg.LibraryID,
		arg.MediaItemID,
		arg.SeasonID,
		arg.EpisodeID,
		arg.Path,
		arg.Status,
	)
	var i MediaFile
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.MediaItemID,
		&i.SeasonID,
		&i.EpisodeID,
		&i.Path,
		&i.Status,
		&i.AddedAt,
	)
	return i, err
}

const createMediaItem = `-- name: CreateMediaItem :one
insert into media_item (type, title, year, tmdb_id)
values ($1, $2, $3, $4)
returning id, type, title, year, tmdb_id, created_at, updated_at
`

type CreateMediaItemParams struct {
	Type   string `json:"type"`
	Title  string `json:"title"`
	Year   *int32 `json:"year"`
	TmdbID *int64 `json:"tmdb_id"`
}

func (q *Queries) CreateMediaItem(ctx context.Context, arg CreateMediaItemParams) (MediaItem, error) {
	row := q.db.QueryRow(ctx, createMediaItem,
		arg.Type,
		arg.Title,
		arg.Year,
		arg.TmdbID,
	)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Title,
		&i.Year,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMediaFile = `-- name: DeleteMediaFile :exec
delete from media_file where id = $1
`

func (q *Queries) DeleteMediaFile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMediaFile, id)
	return err
}

const deleteMediaItem = `-- name: DeleteMediaItem :exec
delete from media_item where id = $1
`

func (q *Queries) DeleteMediaItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMediaItem, id)
	return err
}

const getEpisode = `-- name: GetEpisode :one
select id, season_id, episode_number, title, air_date, tmdb_id, tvdb_id, created_at from media_episode
where id = $1
`

func (q *Queries) GetEpisode(ctx context.Context, id pgtype.UUID) (MediaEpisode, error) {
	row := q.db.QueryRow(ctx, getEpisode, id)
	var i MediaEpisode
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.EpisodeNumber,
		&i.Title,
		&i.AirDate,
		&i.TmdbID,
		&i.TvdbID,
		&i.CreatedAt,
	)
	return i, err
}

const getEpisodeByNumber = `-- name: GetEpisodeByNumber :one
select id, season_id, episode_number, title, air_date, tmdb_id, tvdb_id, created_at from media_episode
where season_id = $1 and episode_number = $2
`

type GetEpisodeByNumberParams struct {
	SeasonID      pgtype.UUID `json:"season_id"`
	EpisodeNumber int32       `json:"episode_number"`
}

func (q *Queries) GetEpisodeByNumber(ctx context.Context, arg GetEpisodeByNumberParams) (MediaEpisode, error) {
	row := q.db.QueryRow(ctx, getEpisodeByNumber, arg.SeasonID, arg.EpisodeNumber)
	var i MediaEpisode
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.EpisodeNumber,
		&i.Title,
		&i.AirDate,
		&i.TmdbID,
		&i.TvdbID,
		&i.CreatedAt,
	)
	return i, err
}

const getMediaFileByLibraryAndPath = `-- name: GetMediaFileByLibraryAndPath :one

select id, library_id, media_item_id, season_id, episode_id, path, status, added_at from media_file where library_id = $1 and path = $2
`

type GetMediaFileByLibraryAndPathParams struct {
	LibraryID pgtype.UUID `json:"library_id"`
	Path      string      `json:"path"`
}

// Files
func (q *Queries) GetMediaFileByLibraryAndPath(ctx context.Context, arg GetMediaFileByLibraryAndPathParams) (MediaFile, error) {
	row := q.db.QueryRow(ctx, getMediaFileByLibraryAndPath, arg.LibraryID, arg.Path)
	var i MediaFile
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.MediaItemID,
		&i.SeasonID,
		&i.EpisodeID,
		&i.Path,
		&i.Status,
		&i.AddedAt,
	)
	return i, err
}

const getMediaItem = `-- name: GetMediaItem :one
select id, type, title, year, tmdb_id, created_at, updated_at from media_item
where id = $1
`

func (q *Queries) GetMediaItem(ctx context.Context, id pgtype.UUID) (MediaItem, error) {
	row := q.db.QueryRow(ctx, getMediaItem, id)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Title,
		&i.Year,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMediaItemByTmdbID = `-- name: GetMediaItemByTmdbID :one
select id, type, title, year, tmdb_id, created_at, updated_at from media_item
where tmdb_id = $1
`

func (q *Queries) GetMediaItemByTmdbID(ctx context.Context, tmdbID *int64) (MediaItem, error) {
	row := q.db.QueryRow(ctx, getMediaItemByTmdbID, tmdbID)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Title,
		&i.Year,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMediaItemByTmdbIDAndType = `-- name: GetMediaItemByTmdbIDAndType :one
select id, type, title, year, tmdb_id, created_at, updated_at from media_item
where tmdb_id = $1 and type = $2
`

type GetMediaItemByTmdbIDAndTypeParams struct {
	TmdbID *int64 `json:"tmdb_id"`
	Type   string `json:"type"`
}

func (q *Queries) GetMediaItemByTmdbIDAndType(ctx context.Context, arg GetMediaItemByTmdbIDAndTypeParams) (MediaItem, error) {
	row := q.db.QueryRow(ctx, getMediaItemByTmdbIDAndType, arg.TmdbID, arg.Type)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Title,
		&i.Year,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeason = `-- name: GetSeason :one
select id, media_item_id, season_number, air_date, created_at from media_season
where id = $1
`

func (q *Queries) GetSeason(ctx context.Context, id pgtype.UUID) (MediaSeason, error) {
	row := q.db.QueryRow(ctx, getSeason, id)
	var i MediaSeason
	err := row.Scan(
		&i.ID,
		&i.MediaItemID,
		&i.SeasonNumber,
		&i.AirDate,
		&i.CreatedAt,
	)
	return i, err
}

const getSeasonByNumber = `-- name: GetSeasonByNumber :one
select id, media_item_id, season_number, air_date, created_at from media_season
where media_item_id = $1 and season_number = $2
`

type GetSeasonByNumberParams struct {
	MediaItemID  pgtype.UUID `json:"media_item_id"`
	SeasonNumber int32       `json:"season_number"`
}

func (q *Queries) GetSeasonByNumber(ctx context.Context, arg GetSeasonByNumberParams) (MediaSeason, error) {
	row := q.db.QueryRow(ctx, getSeasonByNumber, arg.MediaItemID, arg.SeasonNumber)
	var i MediaSeason
	err := row.Scan(
		&i.ID,
		&i.MediaItemID,
		&i.SeasonNumber,
		&i.AirDate,
		&i.CreatedAt,
	)
	return i, err
}

const listEpisodeAvailabilityForSeries = `-- name: ListEpisodeAvailabilityForSeries :many
select
  ms.season_number,
  me.episode_number,
  me.id as episode_id,
  me.title,
  me.air_date,
  mf.id as file_id,
  mf.library_id,
  mf.status
from media_episode me
join media_season ms on me.season_id = ms.id
join media_item mi on ms.media_item_id = mi.id
left join media_file mf on mf.episode_id = me.id
where mi.id = $1
order by ms.season_number, me.episode_number
`

type ListEpisodeAvailabilityForSeriesRow struct {
	SeasonNumber  int32       `json:"season_number"`
	EpisodeNumber int32       `json:"episode_number"`
	EpisodeID     pgtype.UUID `json:"episode_id"`
	Title         *string     `json:"title"`
	AirDate       pgtype.Date `json:"air_date"`
	FileID        pgtype.UUID `json:"file_id"`
	LibraryID     pgtype.UUID `json:"library_id"`
	Status        *string     `json:"status"`
}

func (q *Queries) ListEpisodeAvailabilityForSeries(ctx context.Context, id pgtype.UUID) ([]ListEpisodeAvailabilityForSeriesRow, error) {
	rows, err := q.db.Query(ctx, listEpisodeAvailabilityForSeries, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEpisodeAvailabilityForSeriesRow
	for rows.Next() {
		var i ListEpisodeAvailabilityForSeriesRow
		if err := rows.Scan(
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.EpisodeID,
			&i.Title,
			&i.AirDate,
			&i.FileID,
			&i.LibraryID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesForSeason = `-- name: ListEpisodesForSeason :many

select id, season_id, episode_number, title, air_date, tmdb_id, tvdb_id, created_at from media_episode
where season_id = $1
order by episode_number asc
`

// Episodes
func (q *Queries) ListEpisodesForSeason(ctx context.Context, seasonID pgtype.UUID) ([]MediaEpisode, error) {
	rows, err := q.db.Query(ctx, listEpisodesForSeason, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaEpisode
	for rows.Next() {
		var i MediaEpisode
		if err := rows.Scan(
			&i.ID,
			&i.SeasonID,
			&i.EpisodeNumber,
			&i.Title,
			&i.AirDate,
			&i.TmdbID,
			&i.TvdbID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaFilesForItem = `-- name: ListMediaFilesForItem :many
select
  mf.id,
  mf.library_id,
  mf.media_item_id,
  mf.season_id,
  mf.episode_id,
  mf.path,
  mf.status,
  mf.added_at,
  ms.season_number,
  me.episode_number
from media_file mf
left join media_season ms on mf.season_id = ms.id
left join media_episode me on mf.episode_id = me.id
where mf.media_item_id = $1
order by mf.added_at desc
`

type ListMediaFilesForItemRow struct {
	ID            pgtype.UUID `json:"id"`
	LibraryID     pgtype.UUID `json:"library_id"`
	MediaItemID   pgtype.UUID `json:"media_item_id"`
	SeasonID      pgtype.UUID `json:"season_id"`
	EpisodeID     pgtype.UUID `json:"episode_id"`
	Path          string      `json:"path"`
	Status        string      `json:"status"`
	AddedAt       time.Time   `json:"added_at"`
	SeasonNumber  *int32      `json:"season_number"`
	EpisodeNumber *int32      `json:"episode_number"`
}

func (q *Queries) ListMediaFilesForItem(ctx context.Context, mediaItemID pgtype.UUID) ([]ListMediaFilesForItemRow, error) {
	rows, err := q.db.Query(ctx, listMediaFilesForItem, mediaItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMediaFilesForItemRow
	for rows.Next() {
		var i ListMediaFilesForItemRow
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.MediaItemID,
			&i.SeasonID,
			&i.EpisodeID,
			&i.Path,
			&i.Status,
			&i.AddedAt,
			&i.SeasonNumber,
			&i.EpisodeNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaItems = `-- name: ListMediaItems :many

select id, type, title, year, tmdb_id, created_at, updated_at from media_item
order by created_at desc
`

// Media queries
func (q *Queries) ListMediaItems(ctx context.Context) ([]MediaItem, error) {
	rows, err := q.db.Query(ctx, listMediaItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaItem
	for rows.Next() {
		var i MediaItem
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Title,
			&i.Year,
			&i.TmdbID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeasonsForMedia = `-- name: ListSeasonsForMedia :many

select id, media_item_id, season_number, air_date, created_at from media_season
where media_item_id = $1
order by season_number asc
`

// Seasons
func (q *Queries) ListSeasonsForMedia(ctx context.Context, mediaItemID pgtype.UUID) ([]MediaSeason, error) {
	rows, err := q.db.Query(ctx, listSeasonsForMedia, mediaItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaSeason
	for rows.Next() {
		var i MediaSeason
		if err := rows.Scan(
			&i.ID,
			&i.MediaItemID,
			&i.SeasonNumber,
			&i.AirDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMediaItem = `-- name: UpdateMediaItem :one
update media_item
set title = $2,
    year = $3,
    tmdb_id = $4,
    updated_at = now()
where id = $1
returning id, type, title, year, tmdb_id, created_at, updated_at
`

type UpdateMediaItemParams struct {
	ID     pgtype.UUID `json:"id"`
	Title  string      `json:"title"`
	Year   *int32      `json:"year"`
	TmdbID *int64      `json:"tmdb_id"`
}

func (q *Queries) UpdateMediaItem(ctx context.Context, arg UpdateMediaItemParams) (MediaItem, error) {
	row := q.db.QueryRow(ctx, updateMediaItem,
		arg.ID,
		arg.Title,
		arg.Year,
		arg.TmdbID,
	)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Title,
		&i.Year,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertEpisode = `-- name: UpsertEpisode :one
insert into media_episode (season_id, episode_number, title, air_date, tmdb_id, tvdb_id)
values ($1, $2, $3, $4, $5, $6)
on conflict (season_id, episode_number)
do update set title = excluded.title,
              air_date = excluded.air_date,
              tmdb_id = excluded.tmdb_id,
              tvdb_id = excluded.tvdb_id
returning id, season_id, episode_number, title, air_date, tmdb_id, tvdb_id, created_at
`

type UpsertEpisodeParams struct {
	SeasonID      pgtype.UUID `json:"season_id"`
	EpisodeNumber int32       `json:"episode_number"`
	Title         *string     `json:"title"`
	AirDate       pgtype.Date `json:"air_date"`
	TmdbID        *int64      `json:"tmdb_id"`
	TvdbID        *int64      `json:"tvdb_id"`
}

func (q *Queries) UpsertEpisode(ctx context.Context, arg UpsertEpisodeParams) (MediaEpisode, error) {
	row := q.db.QueryRow(ctx, upsertEpisode,
		arg.SeasonID,
		arg.EpisodeNumber,
		arg.Title,
		arg.AirDate,
		arg.TmdbID,
		arg.TvdbID,
	)
	var i MediaEpisode
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.EpisodeNumber,
		&i.Title,
		&i.AirDate,
		&i.TmdbID,
		&i.TvdbID,
		&i.CreatedAt,
	)
	return i, err
}

const upsertSeason = `-- name: UpsertSeason :one
insert into media_season (media_item_id, season_number, air_date)
values ($1, $2, $3)
on conflict (media_item_id, season_number)
do update set air_date = excluded.air_date
returning id, media_item_id, season_number, air_date, created_at
`

type UpsertSeasonParams struct {
	MediaItemID  pgtype.UUID `json:"media_item_id"`
	SeasonNumber int32       `json:"season_number"`
	AirDate      pgtype.Date `json:"air_date"`
}

func (q *Queries) UpsertSeason(ctx context.Context, arg UpsertSeasonParams) (MediaSeason, error) {
	row := q.db.QueryRow(ctx, upsertSeason, arg.MediaItemID, arg.SeasonNumber, arg.AirDate)
	var i MediaSeason
	err := row.Scan(
		&i.ID,
		&i.MediaItemID,
		&i.SeasonNumber,
		&i.AirDate,
		&i.CreatedAt,
	)
	return i, err
}
